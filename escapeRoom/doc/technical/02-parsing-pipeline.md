# Parsing Pipeline

**From Text to Data Structures**

[← Back: DSL Grammar](01-dsl-grammar.md) | [Next: Data Structures →](03-data-structures.md)

---

## Introduction

This document explains how a `.esc` DSL file is transformed from plain text into Java data structures that the game can use. The pipeline consists of three main stages: **Lexical Analysis**, **Parsing**, and **Interpretation**.

## Pipeline Overview

```
┌──────────────┐
│  .esc File   │  Plain text DSL file
│  (String)    │
└──────┬───────┘
       │
       ▼
┌──────────────┐
│    Lexer     │  Tokenization
│   (ANTLR4)   │  "escape_room:" → ESCAPE_ROOM_KW token
└──────┬───────┘
       │
       ▼
┌──────────────┐
│    Parser    │  Syntax analysis
│   (ANTLR4)   │  Creates parse tree (CST)
└──────┬───────┘
       │
       ▼
┌──────────────┐
│ Interpreter  │  Semantic analysis
│  (Listener)  │  Traverse parse tree
└──────┬───────┘
       │
       ▼
┌──────────────┐
│ EscapeRoom   │  Final data structure
│  Definition  │  Ready for game generation
└──────────────┘
```

## Stage 1: Lexical Analysis (Lexer)

### Purpose

Convert character stream into tokens.

### Implementation

**Class**: `dsl.parser.EscapeRoomDSLLexer` (auto-generated by ANTLR4)

**Process**:

```java
// Read file content
String input = Files.readString(Paths.get("demo_room.esc"));

// Create character stream
CharStream charStream = CharStreams.fromString(input);

// Create lexer
EscapeRoomDSLLexer lexer = new EscapeRoomDSLLexer(charStream);
```

### Tokenization Example

**Input text**:

```
escape_room:
metadata:
    title: "My Room"
```

**Token stream**:

```
1. ESCAPE_ROOM_KW  ("escape_room:")
2. NEWLINE         ("\n")
3. METADATA_KW     ("metadata:")
4. NEWLINE         ("\n")
5. TITLE_KW        ("title:")
6. STRING          ("My Room")
7. NEWLINE         ("\n")
8. EOF             (end of file)
```

### Token Types

The lexer produces various token types:

| Token Type | Example                  | Description          |
| ---------- | ------------------------ | -------------------- |
| Keyword    | `escape_room:`           | Reserved words       |
| Identifier | `entrance`, `golden_key` | User-defined names   |
| String     | `"A dark room"`          | Quoted text          |
| Integer    | `42`, `100`              | Numeric values       |
| Boolean    | `true`, `false`          | Boolean values       |
| Symbol     | `:`, `[`, `]`, `,`       | Structural symbols   |
| Whitespace | spaces, tabs, newlines   | Formatting (ignored) |

### Error Handling

The lexer detects:

-   Invalid characters
-   Unterminated strings
-   Malformed numbers

**Example error**:

```
line 3:10 token recognition error at: '@'
```

## Stage 2: Parsing (Parser)

### Purpose

Build a parse tree (Concrete Syntax Tree) from tokens.

### Implementation

**Class**: `dsl.parser.EscapeRoomDSLParser` (auto-generated by ANTLR4)

**Process**:

```java
// Create token stream from lexer
CommonTokenStream tokens = new CommonTokenStream(lexer);

// Create parser
EscapeRoomDSLParser parser = new EscapeRoomDSLParser(tokens);

// Parse starting from 'start' rule
EscapeRoomDSLParser.StartContext parseTree = parser.start();
```

### Parse Tree Structure

**DSL Input**:

```yaml
escape_room:
metadata:
    title: "Test"

rooms:
    hall:
        x: 5
        y: 10
```

**Parse Tree** (simplified):

```
StartContext
└── Escape_roomContext
    ├── Terminal("escape_room:")
    ├── MetadataContext
    │   ├── Terminal("metadata:")
    │   ├── Terminal("title:")
    │   └── Terminal(STRING: "Test")
    └── RoomsContext
        ├── Terminal("rooms:")
        └── RoomContext
            ├── Terminal(ID: "hall")
            ├── Terminal("x:")
            ├── Terminal(INT: 5)
            ├── Terminal("y:")
            └── Terminal(INT: 10)
```

### Parse Tree Nodes

Each node in the parse tree is a **Context** object:

```java
// Context classes generated by ANTLR4
public class Escape_roomContext extends ParserRuleContext {
    public MetadataContext metadata();
    public RoomsContext rooms();
    public ItemsContext items();
    // ...
}

public class RoomContext extends ParserRuleContext {
    public TerminalNode ID();
    public List<TerminalNode> STRING();
    public List<TerminalNode> INT();
    // ...
}
```

### Error Recovery

The parser performs automatic error recovery:

```java
// Enable error reporting
parser.removeErrorListeners();
parser.addErrorListener(new BaseErrorListener() {
    @Override
    public void syntaxError(Recognizer<?, ?> recognizer,
                           Object offendingSymbol,
                           int line, int charPositionInLine,
                           String msg, RecognitionException e) {
        System.err.println("Syntax error at line " + line + ":" +
                          charPositionInLine + " - " + msg);
    }
});
```

**Example error**:

```
Syntax error at line 8:4 - mismatched input 'widht' expecting 'width:'
```

## Stage 3: Interpretation (Semantic Analysis)

### Purpose

Convert parse tree into meaningful data structures.

### Implementation

**Class**: `dsl.EscapeRoomInterpreter`

**Pattern**: Listener pattern (Visitor pattern variant)

```java
public class EscapeRoomInterpreter extends EscapeRoomDSLBaseListener {
    private EscapeRoomDefinition definition;
    private String currentId;
    private Room currentRoom;

    public EscapeRoomInterpreter() {
        this.definition = new EscapeRoomDefinition();
    }

    // Called when entering a room definition
    @Override
    public void enterRoom(EscapeRoomDSLParser.RoomContext ctx) {
        currentRoom = new Room();
        currentId = ctx.ID(0).getText(); // Get room name
        definition.rooms.put(currentId, currentRoom);

        // Extract properties...
    }
}
```

### Traversal Process

**Tree Walker**:

```java
// Create interpreter
EscapeRoomInterpreter interpreter = new EscapeRoomInterpreter();

// Walk the parse tree
ParseTreeWalker walker = new ParseTreeWalker();
walker.walk(interpreter, parseTree);

// Get result
EscapeRoomDefinition definition = interpreter.getDefinition();
```

**Traversal order**:

```
1. enterStart()
2.   enterEscape_room()
3.     enterMetadata()
4.     exitMetadata()
5.     enterRooms()
6.       enterRoom()  // First room
7.       exitRoom()
8.       enterRoom()  // Second room
9.       exitRoom()
10.    exitRooms()
11.  exitEscape_room()
12. exitStart()
```

### Data Extraction

The interpreter extracts data from parse tree nodes:

```java
@Override
public void enterMetadata(EscapeRoomDSLParser.MetadataContext ctx) {
    definition.metadata = new Metadata();

    // Extract title
    if (ctx.STRING() != null && !ctx.STRING().isEmpty()) {
        String title = ctx.STRING(0).getText();
        // Remove quotes: "My Room" → My Room
        title = title.substring(1, title.length() - 1);
        definition.metadata.title = title;
    }

    // Extract max_time
    if (ctx.INT() != null) {
        definition.metadata.maxTime = Integer.parseInt(ctx.INT().getText());
    }
}
```

### String Processing

**Quote Removal**:

```java
String raw = ctx.STRING().getText();  // "Hello World"
String clean = raw.substring(1, raw.length() - 1);  // Hello World
```

**Multiline Strings** (ASCII patterns):

```java
if (ctx.multiline_string() != null) {
    String pattern = ctx.multiline_string().getText();
    // Remove """ delimiters
    if (pattern.startsWith("\"\"\"") && pattern.endsWith("\"\"\"")) {
        pattern = pattern.substring(3, pattern.length() - 3);
    }
    currentRoom.pattern = pattern;
}
```

### Array Processing

```java
// Extract array: [item1, item2, item3]
if (ctx.array() != null) {
    List<String> items = new ArrayList<>();
    for (TerminalNode idNode : ctx.array().ID()) {
        items.add(idNode.getText());
    }
    currentRoom.items = items;
}
```

### Validation

The interpreter performs semantic validation:

```java
@Override
public void exitEscape_room(EscapeRoomDSLParser.Escape_roomContext ctx) {
    // Validate room connections exist
    for (var entry : definition.rooms.entrySet()) {
        Room room = entry.getValue();
        if (room.connections != null) {
            for (String connectedRoomId : room.connections) {
                if (!definition.rooms.containsKey(connectedRoomId)) {
                    System.err.println("Warning: Room '" + entry.getKey() +
                        "' connects to undefined room '" + connectedRoomId + "'");
                }
            }
        }
    }

    // Validate item locations
    // Validate quiz rewards
    // etc.
}
```

## Complete Pipeline Example

### Input File (`demo_room.esc`)

```yaml
escape_room:
metadata:
    title: "Simple Test"

rooms:
    hall:
        x: 0
        y: 0
        width: 10
        height: 10
        connections: [vault]

    vault:
        x: 15
        y: 0
        width: 8
        height: 8

items:
    key:
        type: key
        description: "A key"
        location: hall
```

### Execution Code

```java
// In DSLEscapeRoom.java
public static EscapeRoomDefinition parseDSL(String filePath) throws IOException {
    // 1. Read file
    String input = Files.readString(Paths.get(filePath));

    // 2. Lexical analysis
    CharStream charStream = CharStreams.fromString(input);
    EscapeRoomDSLLexer lexer = new EscapeRoomDSLLexer(charStream);

    // 3. Parsing
    CommonTokenStream tokens = new CommonTokenStream(lexer);
    EscapeRoomDSLParser parser = new EscapeRoomDSLParser(tokens);
    EscapeRoomDSLParser.StartContext parseTree = parser.start();

    // 4. Interpretation
    EscapeRoomInterpreter interpreter = new EscapeRoomInterpreter();
    ParseTreeWalker walker = new ParseTreeWalker();
    walker.walk(interpreter, parseTree);

    // 5. Return result
    return interpreter.getDefinition();
}
```

### Output Structure

```java
EscapeRoomDefinition {
    metadata = Metadata {
        title = "Simple Test"
        description = null
        difficulty = null
        maxTime = 0
    }
    rooms = {
        "hall" -> Room {
            x = 0, y = 0
            width = 10, height = 10
            connections = ["vault"]
        },
        "vault" -> Room {
            x = 15, y = 0
            width = 8, height = 8
            connections = []
        }
    }
    items = {
        "key" -> Item {
            type = "key"
            description = "A key"
            location = "hall"
        }
    }
}
```

## Performance Characteristics

### Typical Timing (100-line DSL file)

| Stage          | Time      | Memory     |
| -------------- | --------- | ---------- |
| File I/O       | ~5ms      | Negligible |
| Lexing         | ~10ms     | ~50KB      |
| Parsing        | ~30ms     | ~200KB     |
| Interpretation | ~20ms     | ~100KB     |
| **Total**      | **~65ms** | **~350KB** |

### Optimization Strategies

1. **Cache parsed definitions** (if loading multiple times)
2. **Lazy validation** (validate on-demand)
3. **Parallel processing** (parse multiple files concurrently)

## Error Handling Strategy

### Three-Level Error Handling

**1. Lexical Errors** (malformed tokens):

```
line 3:5 token recognition error at: '@invalid'
```

**2. Syntax Errors** (grammar violations):

```
line 7:10 mismatched input 'widht' expecting 'width:'
```

**3. Semantic Errors** (logical issues):

```
Warning: Room 'entrance' connects to undefined room 'treasure'
Warning: Quiz 'quiz1' rewards undefined item 'golden_key'
```

### Error Recovery

```java
// Continue parsing after errors
parser.setErrorHandler(new DefaultErrorStrategy() {
    @Override
    public void recover(Parser recognizer, RecognitionException e) {
        // Log error but continue
        super.recover(recognizer, e);
    }
});
```

## Debugging the Pipeline

### Enable Debug Output

```java
// Lexer debugging
lexer.setTrace(true);

// Parser debugging
parser.setTrace(true);

// Print parse tree
System.out.println(parseTree.toStringTree(parser));
```

### Visualize Parse Tree

```java
// Generate DOT format for Graphviz
import org.antlr.v4.runtime.tree.Trees;

String treeString = Trees.toStringTree(parseTree, parser);
System.out.println(treeString);
```

## Interpreter Patterns

### State Management

```java
public class EscapeRoomInterpreter extends EscapeRoomDSLBaseListener {
    // Global state
    private EscapeRoomDefinition definition;

    // Context-specific state
    private String currentId;        // Current item/room/npc ID
    private Room currentRoom;        // Current room being parsed
    private Item currentItem;        // Current item being parsed
    private Quiz currentQuiz;        // Current quiz being parsed
    private NPC currentNPC;          // Current NPC being parsed
}
```

### Enter/Exit Pairs

```java
@Override
public void enterRoom(EscapeRoomDSLParser.RoomContext ctx) {
    // Setup: create new room
    currentRoom = new Room();
    currentId = ctx.ID(0).getText();
}

@Override
public void exitRoom(EscapeRoomDSLParser.RoomContext ctx) {
    // Cleanup: store room and reset
    definition.rooms.put(currentId, currentRoom);
    currentRoom = null;
    currentId = null;
}
```

## Alternative: Visitor Pattern

While we use the Listener pattern, ANTLR4 also supports Visitor pattern:

```java
public class EscapeRoomVisitor extends EscapeRoomDSLBaseVisitor<Void> {
    @Override
    public Void visitRoom(EscapeRoomDSLParser.RoomContext ctx) {
        // Process room
        Room room = new Room();
        room.x = Integer.parseInt(ctx.INT(0).getText());
        // ...
        return null;
    }
}
```

**Listener vs Visitor**:

-   **Listener**: Passive, walker controls traversal
-   **Visitor**: Active, visitor controls traversal
-   **Choice**: Listener is simpler for our use case

## Summary

| Stage           | Input            | Output          | Purpose           |
| --------------- | ---------------- | --------------- | ----------------- |
| **Lexer**       | Character stream | Token stream    | Tokenization      |
| **Parser**      | Token stream     | Parse tree      | Syntax analysis   |
| **Interpreter** | Parse tree       | Data structures | Semantic analysis |

**Key Classes**:

-   `EscapeRoomDSLLexer` - Tokenization
-   `EscapeRoomDSLParser` - Parsing
-   `EscapeRoomInterpreter` - Interpretation
-   `EscapeRoomDefinition` - Final output

---

**Next**: [Data Structures →](03-data-structures.md)

Learn about the internal data structures used to represent escape rooms.
